<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Min-Heap</title>
    <link rel="stylesheet" href="../prism.css"> <!-- Link to your external CSS file -->
    <link rel="stylesheet" href="../style.css"> <!-- Link to your external CSS file -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
    
<body>
    <a href="https://sarimbaig01.github.io/proghack/" class="back-link top-right">‚Üê Back</a>

    <div class="toc">
        <h2>Contents</h2>
      
        <a href="#intro">Introduction</a>
        <a href="#math1">Height of a complete binary tree</a>
        <a href="#task1">Task 1: Print the heap tree</a>
      <!--
        <a href="#terms1">Some terminology</a>
        <a href="#task1">Task 1: Solve a 9x9 Sudoku board</a>
        <a href="#terms2">Further terminology</a>
        <a href="#task2">Task 2: Implement heuristics</a>
        <a href="#heuristic1" class="sub-item">Minimum remaining values heuristic (MRV)</a>
        <a href="#heuristic1" class="sub-item">Least constrained value heuristic (LCV)</a>
      -->
    </div>


    <div class="statement">
        <h1>Binary Min-Heap</h1>
      <section class="statement">

          <div class="intro" id="intro">
            <h2>Introduction</h2>
              
            <p>Imagine a network host receiving packets at hundreds of thousands per second. Due to the nature of network communication, some packets might be delivered out of order. We know that the out-of-order packets are only within a span of <code>N</code> consecutive sequence numbers. The host needs to maintain a buffer of the last <code>N</code> received packets and retrieve packets from the buffer based on the sequence number (smallest sequence number first to ensure ordered delivery). The buffer should provide the ability to find and remove the packet with the smallest sequence number efficiently, specifically, in around \(\log_2 N\) (or simply <code>lgN</code>) operations. This problem presents an ideal application for a data structure known as a <strong>binary Min-Heap</strong>.</p>

            <p>Physically, a binary heap is stored as a vector; however, it is interpreted as a tree. The index numbers of the vector elements are mapped to the nodes of the logical tree. Typically, in theory, the vector is assumed to begin from index 1; however, in practical implementations, index 0 might be considered the first element. In our description here, we will follow the convention of considering the element at index 1 as the root of the tree. The situation is depicted in Figure 1 below.</p>

            <p>add fig...</p>
            <!--
              <div class="img-container">
                    <figure style="display: inline-block; margin: 10px; text-align: center;">
                        <img  src="./img/Sudoku1a.png">
                        <img  src="./img/Sudoku1b.png">
                        <figcaption>Figure 1: A partially filled Sudoku board representing a typical input and a corresponding solution (a valid output)</figcaption>
                    </figure>
              </div>
            -->

            <p>The structure of the tree is encoded in three simple relationships, given below. For a given node \( i \), its left child is found at \( 2i \), the right child at \( 2i + 1 \), and the parent of \( i \) is found at \( \frac{i}{2} \).</p>
                <p>
                    \[
                    \text{Left child of } i: \quad 2i
                    \]
                    \[
                    \text{Right child of } i: \quad 2i + 1
                    \]
                    \[
                    \text{Parent of } i: \quad \frac{i}{2}
                    \]
                </p>
            <p>The type of tree shown in Figure 1 is called a complete tree. This is a tree in which all levels, except possibly the last level, are full (i.e., they are not missing any nodes). The last level may not be full; however, the nodes in it must be aligned to the left, meaning there are no gaps between nodes.</p>

          
          <div class="math1" id="math1">
            <fieldset>
                <legend>Height of a complete binary tree</legend>
                <p>If \( N \) is the number of nodes in the heap and \( h \) is the height of the tree, then the total number of nodes in a complete binary tree can be expressed as a geometric series:</p>
                <p>\[
                N = 2^0 + 2^1 + 2^2 + \dots + 2^h
                \]</p>
                <p>This series sums to:</p>
                <p>\[
                N = 2^{h+1} - 1
                \]</p>
                <p>\[
                \Rightarrow N + 1 = 2^{h+1}
                \]</p>
                <p>\[
                \Rightarrow h + 1 = \log_2(N + 1)
                \]</p>
                <p>\[
                \Rightarrow h = \log_2(N + 1) - 1
                \]</p>
                <p>This means that any operation on the heap that requires traversing a path from the root to a leaf (or vice versa) will take a constant multiple of \( \log_2(N) \) basic operations to complete.</p>
            </fieldset>
        </div>

        <div class="intro2" id="intro2">
            <h3>The shape and order properties</h3>
            <p>A binary heap is required to maintain two properties at all times:</p>
            <p><ul>
                <li><strong>Shape property:</strong> The heap must always be a complete binary tree.</li>
                <li><strong>Order property:</strong> For any node \( i \), the value at \( i \) must be less than or equal to the values in its child nodes (if they exist), i.e., the nodes at \( 2i \) and \( 2i + 1 \). There is no order constraint among sibling nodes, however.</li>
            </ul></p>          
        </div>

        <div class="task1" id="task1">
            <h2>Print the heap tree</h2>
            <p>As we implement a binary heap, it will be useful to be able to view the data in the vector as the logical heap tree. We need to write a function called <code>printHeap</code> to do this for us. The function has a simple prototype shown below. </p>
            <div class="code-container" data-filename="./cpp/binh1.cpp">
                <pre><code class="language-cpp" id="cpp-code1">
                </code></pre>
            </div>  
            <p>Provide a full implementation for this function. The function should be able to print the heap in a tree-like format.</p>
            <p>For example, for the vector <strong> {2, 3, 6, 4, 7, 6, 11, 5, 5, 8, 11, 7, 19, 13, 11} </strong>, the tree is printed as:</p>
            <p><strong>[2]<br>
            [3,6]<br>
            [4,7][6,11]<br>
            [5,5][8,11][7,19][13,11]</strong></p>
            <p>It should also print the corresponding vector to make it convenient for us to map the elements in the two structures. Note that the output shown below uses square brackets to enclose siblings at each level, and siblings are separated by commas. There are no spaces anywhere. There is one level per line.</p>
        </div>



        <!-- Prism.js JavaScript -->
        <script src="../prism.js"></script> <!-- Adjust the path as needed -->
        <script src="../insertCode.js"></script> <!-- Link to your external JavaScript file -->
      </section>
    </div>
</body>
</html>


