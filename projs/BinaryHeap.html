<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Min-Heap</title>
    <link rel="stylesheet" href="../prism.css"> <!-- Link to your external CSS file -->
    <link rel="stylesheet" href="../style.css"> <!-- Link to your external CSS file -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
    
<body>
    <a href="https://sarimbaig01.github.io/proghack/" class="back-link top-right">‚Üê Back</a>

    <div class="toc">
        <h2>Contents</h2>
      
        <a href="#intro">Introduction</a>
        <a href="#math1">Height of a complete binary tree</a>
        <a href="#task1">Task 1: Print the heap tree</a>
        <a href="#task2">Task 2: heapifyDown and heapifyUp</a>
      <!--
        <a href="#terms1">Some terminology</a>
        <a href="#task1">Task 1: Solve a 9x9 Sudoku board</a>
        <a href="#terms2">Further terminology</a>
        <a href="#task2">Task 2: Implement heuristics</a>
        <a href="#heuristic1" class="sub-item">Minimum remaining values heuristic (MRV)</a>
        <a href="#heuristic1" class="sub-item">Least constrained value heuristic (LCV)</a>
      -->
    </div>


    <div class="statement">
        <h1>Binary Min-Heap</h1>
      <section class="statement">

          <div class="intro" id="intro">
            <h2>Introduction</h2>
              
            <p>Imagine a network host receiving packets at hundreds of thousands per second. Due to the nature of network communication, some packets might be delivered out of order. We know that the out-of-order packets are only within a span of <code>N</code> consecutive sequence numbers. The host needs to maintain a buffer of the last <code>N</code> received packets and retrieve packets from the buffer based on the sequence number (smallest sequence number first to ensure ordered delivery). The buffer should provide the ability to find and remove the packet with the smallest sequence number efficiently, specifically, in around \(\log_2 N\) (or simply <code>lgN</code>) operations. This problem presents an ideal application for a data structure known as a <strong>binary Min-Heap</strong>.</p>

            <p>Physically, a binary heap is stored as a vector; however, it is interpreted as a tree. The index numbers of the vector elements are mapped to the nodes of the logical tree. Typically, in theory, the vector is assumed to begin from index 1; however, in practical implementations, index 0 might be considered the first element. In our description here, we will follow the convention of considering the element at index 1 as the root of the tree. The situation is depicted in Figure 1 below.</p>
            
            <div class="img-container">
                <figure>
                  <img src="./img/BinaryHeap1.png" width="500" height="400">
                  <figcaption>Figure 1: The tree interpretation of a binary Min-Heap. This tree corresponds to the vector: <strong>[4, 4, 6, 11, 8, 6, 11, 13, 12, 20, 9]</strong>. Below each node is the index of the value in that node in the corresponding vector. In this picture we have shown indices as beginning from 1. This is a convention followed in theoretical descriptions of binary heaps. In our implementation the indices will start from 0 (as the root). (Image created using yEd: https://www.yworks.com/products/yed/)</figcaption>
                </figure>
            </div>

            <p>The structure of the tree is encoded in three simple relationships, given below. For a given node \( i \), its left child is found at \( 2i \), the right child at \( 2i + 1 \), and the parent of \( i \) is found at \( \frac{i}{2} \).</p>
                <p>
                    \[
                    \text{Left child of } i: \quad 2i
                    \]
                    \[
                    \text{Right child of } i: \quad 2i + 1
                    \]
                    \[
                    \text{Parent of } i: \quad \frac{i}{2}
                    \]
                </p>
            <p>The type of tree shown in Figure 1 is called a complete tree. This is a tree in which all levels, except possibly the last level, are full (i.e., they are not missing any nodes). The last level may not be full; however, the nodes in it must be aligned to the left, meaning there are no gaps between nodes.</p>

          
          <div class="math1" id="math1">
            <fieldset>
                <legend>Height of a complete binary tree</legend>
                <p>If \( N \) is the number of nodes in the heap and \( h \) is the height of the tree, then the total number of nodes in a complete binary tree can be expressed as a geometric series:</p>
                <p>\[
                N = 2^0 + 2^1 + 2^2 + \dots + 2^h
                \]</p>
                <p>This series sums to:</p>
                <p>\[
                N = 2^{h+1} - 1
                \]</p>
                <p>\[
                \Rightarrow N + 1 = 2^{h+1}
                \]</p>
                <p>\[
                \Rightarrow h + 1 = \log_2(N + 1)
                \]</p>
                <p>\[
                \Rightarrow h = \log_2(N + 1) - 1
                \]</p>
                <p>This means that any operation on the heap that requires traversing a path from the root to a leaf (or vice versa) will take a constant multiple of \( \log_2(N) \) basic operations to complete.</p>
            </fieldset>
        </div>

        <div class="intro2" id="intro2">
            <h3>The shape and order properties</h3>
            <p>A binary heap is required to maintain two properties at all times:</p>
            <p><ul>
                <li><strong>Shape property:</strong> The heap must always be a complete binary tree.</li>
                <li><strong>Order property:</strong> For any node \( i \), the value at \( i \) must be less than or equal to the values in its child nodes (if they exist), i.e., the nodes at \( 2i \) and \( 2i + 1 \). There is no order constraint among sibling nodes, however.</li>
            </ul></p>          
        </div>

        <div class="task1" id="task1">
            <h2>Task 1: Print the heap tree</h2>
            <p>As we implement a binary heap, it will be useful to be able to view the data in the vector as the logical heap tree. We need to write a function called <code>printHeap</code> to do this for us. The function has a simple prototype shown below. </p>
            <div class="code-container" data-filename="./cpp/binh1.cpp">
                <pre><code class="language-cpp" id="cpp-code1">
                </code></pre>
            </div>  
            <p>Provide a full implementation for this function. The function should be able to print the heap in a format that, even though not completely tree-like, makes it easier to read the tree structure.</p>
            <p>For example, for the vector: <strong> [4, 4, 6, 11, 8, 6, 11, 13, 12, 20, 9, 6, 19, 13] </strong>, the tree could be printed as:</p>
            <p><strong>[4]<br>
            [4,6]<br>
            [11,8][6,11]<br>
            [13,12][20,9][6,19][13]</strong></p>
            <p>The function prints one level per line. It uses square brackets to enclose siblings at each level (single values appear within brackets when they have no siblings) and siblings are separated by commas. There are no spaces.</p>
        </div>

        <div class="task2" id="task2">
            <h2>Task 2: heapifyDown and heapifyUp</h2>
            <p>One of the fundamental operations required to maintain a binary min-heap is called heapify. Its task may be described as follows:</p>
            <p>Given a binary min heap, of valid shape, and the values of all but one node \( i \) in the correct place according to the order property, move the value at \( i \) to its correct place according to the order property, while maintaining the shape of the heap.</p>
            <p>In the context of heapify, the value at \( i \) may violate the order property in one of two possible ways: (1) the value at \( i \) is greater than the value of a child of \( i \), or (2) the value at \( i \) is smaller than its parent.</p>
            <p>The method used to resolve (1) is called heapify down, and the method to resolve (2) is heapify up. Our task in this section is to write the functions <code>heapifyDown</code> and <code>heapifyUp</code> , prototypes shown below.</p> 
       

            <div class="heapifyDown" id="heapifyDown">
                <h3>heapifyDown</h3>
                <p>Figure 2 below shows the action of heapifyDown. We begin with a properly shaped heap in which one node, at index 0 in this case, contains a value that is greater than a child's value (both children's values in this case). The algorithm proceeds to move this value down the heap, one level at a time, using the following rules:</p>
                <div class="img-container">
                    <figure>
                        <img src="./img/BinaryHeap2.png" width="800" height="600">
                        <figcaption>Figure 2: Shows heapifyDown in action. Starting with an invalid value at the root, namely 26, it is moved down the heap using the algorithm described in this section. (Image created using yEd: https://www.yworks.com/products/yed/)</figcaption>
                    </figure>
                </div>
                <p><strong>Case 1:</strong> If the node at \( i \) has only one child \( j \), and the value at \( i \) is greater than the value at \( j \): swap the value at \( i \) with the value at \( j \). Set \( i \) to \( j \) and repeat.</p>
                <p><strong>Case 2:</strong> If the node at \( i \) has two children \( j \) and \( k \), and the value at \( j \) is less than or equal to the value at \( k \) and less than the value at \( i \): swap the value at \( i \) with the value at \( j \). Set \( i \) to \( j \) and repeat.</p>
                <p><strong>Case 3:</strong> If \( i \) has no children, or the value at \( i \) is less than or equal to the values at the children, STOP.</p>
            </div>

             <div class="heapifyDown" id="heapifyDown">
                <h3>heapifyUp</h3>
                <p>todo...</p>
             </div>
     </div>


        <!-- Prism.js JavaScript -->
        <script src="../prism.js"></script> <!-- Adjust the path as needed -->
        <script src="../insertCode.js"></script> <!-- Link to your external JavaScript file -->
      </section>
    </div>
</body>
</html>


