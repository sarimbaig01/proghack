<!DOCTYPE html>
<html lang="en">

<head>
    <title>Sorting Binary Identifiers</title>

    <div class="common-head">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <!-- Style sheets -->
        <link rel="stylesheet" href="../style.css">
        <link rel="stylesheet" href="../prism.css">

        <!-- Scripts -->
        <script src="../prism.js"></script>
        <script src="../insertCode.js"></script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </div>
</head>

<body>
    <a href="https://sarimbaig01.github.io/ss/" class="back-link top-right">‚Üê Back</a>

    <!--<div class="toc">
        <h5>Table of Contents</h5>
        1. <a href="#inspect">Inspecting the hierarchy</a><br><br>
        2. <a href="#navigate">Navigating the hierarchy</a><br><br>
        3. <a href="#permissions">File listing and permissions</a><br><br>
    </div>-->

    <div class="statement">
        <h1 class="align-with-statement"> Sorting Binary Identifiers for Communication Analysis</h1>
        <section class="statement">
            <h2>Introduction</h2>
            <p>
                We consider a network server that receives binary identifiers in the form of \(0/1\) strings, each
                of length \(d\), from up to \(2^d\) communicating machines.</p>
            <p> These identifiers may arrive in tens of thousands, including repeated times from the same machine. To
                analyze the communication behavior of each machine
                effectively, it is essential to sort the received data.</p>
            <p>Sorting enables efficient organization of the data associated with the identifiers. This may further
                enable the server to detect patterns, count interactions, and identify anomalies or
                irregularities in communication behavior.
            </p>

            <h3>Problem definition</h3>
            <p>
                We are given a vector <code>bstrings</code> of \(N\) binary strings, where each string is of fixed
                length \(d\). The task is to sort the strings in <strong>non-decreasing order of the binary numbers they
                    represent</strong>. Each string represents a binary number, and the sorting must respect the
                numerical value of these numbers.
            </p>
            <p>
                For example:
            </p>
            <p>
                <strong>Input:</strong> {"100", "110", "101", "110", "000", "101"}<br>
                <strong>Sorted Output:</strong> {"000", "100", "101", "101", "110", "110"}
            </p>
            <p>
                <strong>Notes:</strong><br>
                1. All strings in the vector have the same length \(d\).<br>
                2. The number of strings, \(N\), can be any positive integer.<br>
                3. The same string may repeat any number of times.
            </p>

            <h3>Implementation 1: Sorting using repeated selection (slow)</h3>
            <p>
                One of the simplest sorting algorithms works as follows:
            </p>

            <div class="text-box">
                <p>
                    Traverse through the elements (strings, in this case) of the vector, and for each element:
                <ul>
                    <li>Find the smallest element from the current position to the end of the vector.</li>
                    <li> Swap the current element with the smallest element.</li>
                </ul>
                </p>
            </div>


            <p>Let's begin by implementing this simple method in C++. The following code provides an empty sorting
                function (to be implemented by you), and a main that tests it.</p>
            <div class="code-container" data-filename="./cpp/bin_str1.cpp">
                <pre><code class="language-cpp" id="cpp-code1">
                </code></pre>
            </div>

            <h3>Implementation 2: Sorting by digits, using auxiliary storage (fast)</h3>
            <p>
                This implementation sorts \(0/1\) strings by exploiting their particular structure.
            </p>

            <p>It uses one digit position at a time as the sorting criterion.</p>

            <p>The method is shown in Figure 1 below.</p>

            <div class="img-container">
                <figure class="left-aligned">
                    <img src="./img/SortingByDigits.png" width="800" height="700">
                    <figcaption>Figure 1: The working of the digit-by-digit sorting method. On each step, the output of
                        the previous step is sorted based on the value of the next digit (moving from the least to most
                        significant digit).</figcaption>
                </figure>
            </div>

            <p> Following is a brief description of the method. The description has been kept brief intentionally, and
                not all implementation details have been specified. However, breaking the task into smaller functions
                will help. </p>

            <p>A key point is that if two strings \(x\)
                and \(y\) have the same digit at any step, their relative order from the previous step must be
                preserved.
                This is critical for the method to work correctly.
            </p>

            <div class="text-box">
                <p>
                    Traverse through the \(d\) digit positions of the \(0/1\) strings from the least significant to
                    the most significant digit position, and for each position:
                <ul class="none">
                    <li>Move all strings with a \(0\) at that position above the strings with a \(1\) at that position.
                    </li>
                    <li>(Preserve the relative order of strings that have the same digit (0 or 1) at the current
                        position.)</li>
                </ul>
                </p>
            </div>

            <fieldset>
                <legend>Comparison: Repeated Selection vs. Digit-by-Digit Sorting</legend>
                <p>
                    This comparison highlights how the digit-by-digit method is faster than repeated selection for
                    sorting \(N\) strings of length \(d\). Since strings can repeat, the number of strings \(N\) is
                    often much larger than \(d\), as \(N\) represents the total number of elements while \(d\) is just
                    the length of each binary string.
                </p>
                <p>
                    The repeated selection method takes time proportional to \(N^2 \cdot d\), as it repeatedly scans the
                    unsorted portion of the strings to find the smallest, which involves comparing all pairs of strings.
                </p>
                <p>
                    The digit-by-digit method takes time proportional to \(d^2 \cdot N\). At each of the \(d\) digit
                    positions, an additional cost of \(d \cdot N\) arises due to copying or processing the strings while
                    grouping or rearranging them.
                </p>
                <p>
                    For example, consider sorting 1000 8-digit strings. The repeated selection method will require
                    approximately \(N^2 \cdot d = 1000^2 \cdot 8 = 8,000,000\) basic operations. In contrast, the
                    digit-by-digit method will require approximately \(d^2 \cdot N = 8^2 \cdot 1000 = 64,000\) basic
                    operations, making it significantly faster.
                </p>
                <p>
                    The trade-off for the digit-by-digit method is the use of auxiliary storage to group strings during
                    intermediate steps.
                </p>
            </fieldset>

            <p>Finally, implement the digit-by-digit method in C++. The following code provides an empty sorting
                function (to be implemented by you). Use the same main as above to test your function. </p>

                <div class="code-container" data-filename="./cpp/bin_str2.cpp">
                    <pre><code class="language-cpp" id="cpp-code1">
                    </code></pre>
                </div>


        </section>
    </div>
</body>


</html>