<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway's Game of Life</title>
    <link rel="stylesheet" href="../prism.css"> <!-- Adjust the path as needed -->
    <link rel="stylesheet" href="../style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
   <a href="https://sarimbaig01.github.io/proghack/" class="back-link top-right">‚Üê Back</a>

    <div class="toc">
        <h2>Contents</h2>
        <a href="#intro">What is the game of life?</a>
        <a href="#terms">Basic terminology</a>
        <a href="#rules">The rules</a>
        <a href="#task1">Task 1: The basic simulation </a>
        <a href="#fterms">Further terminology</a>
        <a href="#task2">Task 2: Make it toroidal</a>
        <a href="#task3">Task 3: Print useful statistics</a>
        <a href="#task4">Task 4: Detect equilibrium</a>
        <a href="#task5">Task 5: Color-code for age</a>
        
        <!--<a href="#toroidal" class="sub-item">Make it toriodal</a>
        <a href="#stats" class="sub-item">Print statistics</a>
        <a href="#colors" class="sub-item">Color-code for age</a>
        <a href="#equi" class="sub-item">Detect equilibrium</a>
        <a href="#confs">Simulate different initial configurations</a>-->
    </div>

    <div class="statement">
        <h1>Conway's Game of Life</h1>
        <section class="statement">
          <div class="intro" id="intro">
            <h2>What is the game of life?</h2>  
            <p>Conway's Game of Life is a <a href="https://plato.stanford.edu/entries/cellular-automata/" target="_blank">cellular automaton</a> devised by mathematician <a href="https://en.wikipedia.org/wiki/John_Horton_Conway" target="_blank">John Horton Conway</a> in 1970. It's a zero-player game, meaning its evolution is determined by its initial state without any further input. The game is played on an infinite grid of square cells, each of which can be either <i>alive</i> or <i>dead</i>. The state of the grid evolves in discrete time steps according to a set of simple rules based on the states of neighboring cells. Despite simple rules, the Game of Life can produce incredibly complex and varied patterns, being used in practical applications such as <a href="https://arxiv.org/abs/2009.01398" target="_blank">neural networks research</a> in computer science and <a href="https://pubs.aip.org/aapt/ajp/article/91/7/561/2897367/The-game-of-life-as-a-species-model" target="_blank">simulating population dynamics</a> in theoretical biology, among other applications.</p>
          </div>
            
          <div class="terms" id="terms">  
            <fieldset>
              <legend>Basic terminology</legend>
              <p><strong>Cell</strong>: The basic unit in the grid, either alive or dead.</p>
              <p><strong>Grid</strong>: The environment where the Game of Life is played, consisting of cells in a two-dimensional array.</p>
              <p><strong>Neighbor</strong>: Any of the eight surrounding cells influencing a cell's future state.</p>
              <p><strong>Alive</strong>: A cell state that is "on" or active, represented by `1`.</p>
              <p><strong>Dead</strong>: A cell state that is "off" or inactive, represented by `0`.</p>
              <p><strong>Initial Configuration</strong>: The starting arrangement of alive and dead cells in the grid.</p>
              <p><strong>Generation</strong>: A time step where the state of each cell is updated based on the game's rules (the initial configuration being generation 0).</p>
              <p><strong>Survival</strong>: A condition where a live cell remains alive in the next generation.</p>
          </fieldset>
          </div>

          <div class="rules" id="rules">
              <h2>The rules</h2>
                <p>Conway's Game of Life typically uses the B3/S23 rules, which are the most common despite many possible variations. "B3/S23" means a dead cell with exactly three alive neighbors becomes alive (B3), and a live cell with two or three alive neighbors survives (S23). The rules are:</p>
                <ol>
                  <li>Any live cell with fewer than two alive neighbors dies (the underpopulation rule).</li>
                  <li>A live cell with two or three alive neighbors survives (the survival rule).</li>
                  <li>Any live cell with more than three alive neighbors dies (the overcrowding rule).</li>
                  <li>A dead cell with exactly three alive neighbors becomes alive (the reproduction rule).</li>
                </ol>
          </div>

         <div class="task1" id="task1">
             <h2>Task 1: the basic simulation</h2>
             <p>
                 Consider the following simulation of Conway's Game of Life. This simulation uses a 100x100 grid. This is a good size because it allows intricate patterns to emerge without overwhelming computational resources. In this grid, black cells represent alive states, while white cells represent dead states. The initial configuration of the grid is populated randomly with a mix of alive and dead cells. Our first goal is to write code that can produce such simulations, showing the evolution of this grid over any number of generations, continuing until the window is closed by the user.
            </p>
            <div class="video-container">
                <!-- Video with Caption -->
                <figure>
                    <video width="320" height="240" autoplay loop muted>
                        <source src="./mov/gol_100_eq.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <figcaption>Figure 1: Simulation of Conway's Game of Life. This particular simulation begins from a randomly generated initial configuration and eventually reaches equilibrium.</figcaption>
                </figure>
            </div>
             
            <p>Following is a skeleton C++ code using SFML for the graphics (refer to the <a href="https://www.sfml-dev.org/" target="_blank">SFML page</a> for a basic introduction). The code implements some functions while leaving others to be implemented by you. In particular, the functionalities to be implemented include: setting the grid to a random initial configuration, updating the grid to the next generation by applying the four rules stated above. As it is at the moment, when this code is executed, it shows an empty 100 x 100 grid (i.e., all cells are initially dead), and it remains unchanged.</p>

            <p>In particular, you need to implement the following functions:</p>
            <ul>
              <li>generateRandomInitConf</li>
              <li>countAliveNeighbours (to be used inside updateGrid)</li>
              <li>updateGrid</li>
            </ul>

            <p>The following code also shows (in comments) how these functions are used, which should help you figure out which parameters need to be passed and how the implementation should proceed.</p>

             <div class="code-container" data-filename="./cpp/gol1.cpp">
                <pre><code class="language-cpp" id="cpp-code1">
                    <!-- The code will be loaded dynamically here -->
                </code></pre>
            </div>

            <div class="terms" id="fterms">  
                <fieldset>
                    <legend>Further terminology</legend>
                    <p><strong>Age</strong>: The number of generations a cell has been alive.</p>
                    <p><strong>Pattern</strong>: A specific arrangement of live and dead cells in the grid.</p>
                    <p><strong>Period</strong>: The number of generations it takes for an oscillator to return to its initial state.</p>
                    <p><strong>Spaceship</strong>: A pattern that translates itself across the grid over generations.</p>
                    <p><strong>Glider</strong>: A common type of spaceship that moves diagonally across the grid, consisting of 5 live cells in a specific formation.</p>
                    <p><strong>Oscillator</strong>: A pattern that returns to its initial state after a fixed number of generations, known as its period.</p>
                    <p><strong>Still Lifes</strong>: Stable patterns that do not change from one generation to the next.</p>
                    <p><strong>Equilibrium</strong>: A state where the grid either remains unchanged or cycles through the same sequence of configurations repeatedly.</p>
                    <p><strong>Population</strong>: The total number of live cells in the grid \( P(t) = \sum_{i,j} \text{grid}[i][j] \). Purpose: tracks how the number of live cells changes over generations.</p>
                    <p><strong>Growth Rate</strong>: The rate at which the population of live cells changes over time \( G(t) = \frac{P(t+1) - P(t)}{P(t)} \). Purpose: measures how quickly the population is increasing or decreasing.</p>
                    <p><strong>Stability</strong>: The tendency of a pattern to remain unchanged or return to its original configuration after disturbances. One way to calculate stability is by counting the number of cells that do not change state between generations \( \text{Stability} = \frac{\text{Unchanged Cells}}{\text{Total Cells}} \).</p>
                    <p><strong>Entropy</strong>: A measure of the disorder or randomness in the grid. One way to calculate entropy: \( H(t) = - \sum_{i,j} \left( \frac{\text{grid}[i][j]}{N} \right) \log_2 \left( \frac{\text{grid}[i][j]}{N} \right) \) where \(N\) is the total number of cells.</p>
                </fieldset>
            </div>


             <div class="task2" id="task2">
                 <h2>Task 2: Make it toroidal</h2>
                <p>Change the implementation to toroidal to create a grid where the edges wrap around, making the top row adjacent to the bottom row, and the left column adjacent to the right column. This continuous wrap-around effect simulates an infinite, unbounded environment, eliminating edge effects in finite grids. This modification is particularly useful for studying patterns and behaviors that are not influenced by artificial boundaries, such as oscillators and spaceships that can move freely across the grid. To achieve this, make appropriate changes to <span style="font-family: Consolas;">countLiveNeighbours</span> to handle the edge cases in a way to make the grid toroidal.</p>
            </div>

             <div class="task3" id="task3">
                <h2>Task 3: Print useful statistics</h2>
                <p>Implement functionality to print various statistics for each generation of the Game of Life. Printing statistics is useful for analyzing and understanding the dynamics of the grid over time. The statistics to print include generation number, population, growth rate, stability, and entropy (these have been defined in the box above). These metrics help track trends such as how quickly the population is changing, how stable certain patterns are, and the overall randomness or order within the grid. Monitoring these statistics can provide insights into the long-term behavior of patterns, the likelihood of reaching equilibrium, and the evolution of complexity within the grid. You may print the statistics on the console (not on the graphics window).</p>
                <p>Following is a list of prototypes of the functions you need to implement. For generation number it suffices to keep a variable in the main that keeps track of the generation count.</p> 

                <div class="code-container" data-filename="./cpp/gol3.cpp">
                    <pre><code class="language-cpp" id="cpp-code2">
                    </code></pre>
                </div>   
             </div>

            <div class="task4" id="task4">
                <h2>Task 4: Detect equilibrium</h2>
                <p>In this task, you need to detect when the Game of Life grid reaches equilibrium and stop the simulation at that point. This is useful to stop unnecessary computations once the grid no longer changes. Equilibrium is achieved when the grid either becomes static (all cells remain the same) or enters a repeating cycle of configurations (dynamic equilibrium). To detect equilibrium, you need to add the necessary code to identify when the grid reaches one of these states and then stop the simulation, reporting the final statistics. While dynamic equilibrium can theoretically involve long cycles, you only need to cater to cycles of size 10 or less for this task. Make sure to maintain the necessary information and write the required functions to detect equilibrium and manage the simulation accordingly.</p>
            </div>

             <div class="task5" id="task5">
                <h2>Task 5: Color-code for age</h2>
                <p>For this task, you need to maintain the necessary information and write the required code to color-code the simulation based on the age of the cells. In this context, the age of a cell refers to the number of generations it has been alive. Cells that have been alive for longer should appear darker. You can use a gradient where the color darkens progressively with each generation, but for cells that have been alive for 20 generations or more, the color may no longer change. Feel free to experiment with this number to find what works best for your simulation. To achieve this, you will need to modify the code in the drawGrid function. Make sure to update and manage the age of each cell as the simulation progresses. This task will help visualize the longevity and stability of various patterns in the simulation. Ideal visualization depends on several factors, so you are encouraged to experiment with different methods to enhance the quality of your visualization.</p>

                 <div class="video-container">
                    <!-- Video 1 -->
                    <figure style="display: inline-block; margin: 10px;">
                        <video width="320" height="240" autoplay loop muted>
                            <source src="./mov/gol_col1.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </figure>
                    <!-- Video 2 -->
                    <figure style="display: inline-block; margin: 10px;">
                        <video width="320" height="240" autoplay loop muted>
                            <source src="./mov/gol_col2.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </figure>
                    <!-- Video 3 -->
                    <figure style="display: inline-block; margin: 10px;">
                        <video width="320" height="240" autoplay loop muted>
                            <source src="./mov/gol_col3.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </figure>
                    <figcaption>Three different color-codings of the game of life on a 100x100 grid. Can you find a better scheme? Can you explore different backgrounds? Can you go a step further and color-code patterns?</figcaption>
                </div>

                 <p>Some incredibly beautiful things are possible when colorful Game of Life is implemented at high resolutions and made interactive. For example, check out <a href="https://jaxry.github.io/colorful-life/" target="_blank">this beautiful implementation</a> by Lucas Crane.</p>
              </div>



            <!-- Prism.js JavaScript -->
            <script src="../prism.js"></script> <!-- Adjust the path as needed -->
            <script src="../copycode.js"></script> <!-- Link to your external JavaScript file -->
             
        </div>
        </section>
        
    </div>
</body>
</html>
