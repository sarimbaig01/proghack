<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway's Game of Life</title>
    <link rel="stylesheet" href="../prism.css"> <!-- Adjust the path as needed -->
    <link rel="stylesheet" href="../style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
   <a href="https://sarimbaig01.github.io/proghack/" class="back-link top-right">‚Üê Back</a>

    <div class="toc">
        <h2>Contents</h2>
        <a href="#intro">What is the game of life?</a>
        <a href="#terms">Basic terminology</a>
        <a href="#rules">The rules</a>
        <a href="#task">Task 1: the basic simulation </a>
        <a href="#terms">Further terminology</a>
        
        <!--<a href="#toroidal" class="sub-item">Make it toriodal</a>
        <a href="#stats" class="sub-item">Print statistics</a>
        <a href="#colors" class="sub-item">Color-code for age</a>
        <a href="#equi" class="sub-item">Detect equilibrium</a>
        <a href="#confs">Simulate different initial configurations</a>-->
    </div>

    <div class="statement">
        <h1>Conway's Game of Life</h1>
        <section class="statement">
          <div class="intro" id="intro">
            <h2>What is the game of life?</h2>  
            <p>Conway's Game of Life is a <a href="https://plato.stanford.edu/entries/cellular-automata/" target="_blank">cellular automaton</a> devised by mathematician <a href="https://en.wikipedia.org/wiki/John_Horton_Conway" target="_blank">John Horton Conway</a> in 1970. It's a zero-player game, meaning its evolution is determined by its initial state without any further input. The game is played on an infinite grid of square cells, each of which can be either <i>alive</i> or <i>dead</i>. The state of the grid evolves in discrete time steps according to a set of simple rules based on the states of neighboring cells. Despite simple rules, the Game of Life can produce incredibly complex and varied patterns, being used in practical applications such as <a href="https://arxiv.org/abs/2009.01398" target="_blank">neural networks research</a> in computer science and <a href="https://pubs.aip.org/aapt/ajp/article/91/7/561/2897367/The-game-of-life-as-a-species-model" target="_blank">simulating population dynamics</a> in theoretical biology, among other applications.</p>
          </div>
            
          <div class="terms" id="terms">  
            <fieldset>
              <legend>Basic terminology</legend>
              <p><strong>Cell</strong>: The basic unit in the grid, either alive or dead.</p>
              <p><strong>Grid</strong>: The environment where the Game of Life is played, consisting of cells in a two-dimensional array.</p>
              <p><strong>Neighbor</strong>: Any of the eight surrounding cells influencing a cell's future state.</p>
              <p><strong>Alive</strong>: A cell state that is "on" or active, represented by `1`.</p>
              <p><strong>Dead</strong>: A cell state that is "off" or inactive, represented by `0`.</p>
              <p><strong>Initial Configuration</strong>: The starting arrangement of alive and dead cells in the grid.</p>
              <p><strong>Generation</strong>: A time step where the state of each cell is updated based on the game's rules (the initial configuration being generation 0).</p>
              <p><strong>Survival</strong>: A condition where a live cell remains alive in the next generation.</p>
          </fieldset>
          </div>

          <div class="rules" id="rules">
              <h2>The rules</h2>
                <p>Conway's Game of Life typically uses the B3/S23 rules, which are the most common despite many possible variations. "B3/S23" means a dead cell with exactly three alive neighbors becomes alive (B3), and a live cell with two or three alive neighbors survives (S23). The rules are:</p>
                <ol>
                  <li>Any live cell with fewer than two alive neighbors dies (the underpopulation rule).</li>
                  <li>A live cell with two or three alive neighbors survives (the survival rule).</li>
                  <li>Any live cell with more than three alive neighbors dies (the overcrowding rule).</li>
                  <li>A dead cell with exactly three alive neighbors becomes alive (the reproduction rule).</li>
                </ol>
          </div>

         <div class="task" id="task">
             <h2>The task </h2>
             <p>
                 Consider the following simulation of Conway's Game of Life. This simulation uses a 100x100 grid. This is a good size because it allows intricate patterns to emerge without overwhelming computational resources. In this grid, black cells represent alive states, while white cells represent dead states. The initial configuration of the grid is populated randomly with a mix of alive and dead cells. Our first goal is to write code that can produce such simulations, showing the evolution of this grid over any number of generations, continuing until the window is closed by the user.
            </p>
            <div class="video-container">
                <!-- Video with Caption -->
                <figure>
                    <video width="320" height="240" autoplay loop muted>
                        <source src="./mov/gol_100_eq.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <figcaption>Figure 1: Simulation of Conway's Game of Life. This particular simulation begins from a randomly generated initial configuration and eventually reaches equilibrium.</figcaption>
                </figure>
            </div>
             
            <p>Following is a skeleton C++ code using SFML for the graphics (refer to the <a href="https://www.sfml-dev.org/" target="_blank">SFML page</a> for a basic introduction). The code implements some functions while leaving others to be implemented by you. In particular, the functionalities to be implemented include: setting the grid to a random initial configuration, updating the grid to the next generation by applying the four rules stated above. As it is at the moment, when this code is executed, it shows an empty 100 x 100 grid (i.e., all cells are initially dead), and it remains unchanged.</p>

            <p>In particular, you need to implement the following functions:</p>
            <ul>
              <li>generateRandomInitConf</li>
              <li>countAliveNeighbours (to be used inside updateGrid)</li>
              <li>updateGrid</li>
            </ul>

            <p>The following code also shows (in comments) how these functions are used, which should help you figure out which parameters need to be passed and how the implementation should proceed.</p>

             <div class="code-container" data-filename="./cpp/gol1.cpp">
                <pre><code class="language-cpp" id="cpp-code">
                    <!-- The code will be loaded dynamically here -->
                </code></pre>
            </div>

            <div class="#terms" id="#further-terms">  
                <fieldset>
                    <legend>Further terminology</legend>
                    <p><strong>Age</strong>: The number of generations a cell has been alive.</p>
                    <p><strong>Pattern</strong>: A specific arrangement of live and dead cells in the grid.</p>
                    <p><strong>Period</strong>: The number of generations it takes for an oscillator to return to its initial state.</p>
                    <p><strong>Spaceship</strong>: A pattern that translates itself across the grid over generations.</p>
                    <p><strong>Glider</strong>: A common type of spaceship that moves diagonally across the grid, consisting of 5 live cells in a specific formation.</p>
                    <p><strong>Oscillator</strong>: A pattern that returns to its initial state after a fixed number of generations, known as its period.</p>
                    <p><strong>Equilibrium</strong>: A state where the grid either remains unchanged or cycles through the same sequence of configurations repeatedly.</p>
                    <p><strong>Population</strong>: The total number of live cells in the grid \( P(t) = \sum_{i,j} \text{grid}[i][j] \). Purpose: tracks how the number of live cells changes over generations.</p>
                    <p><strong>Growth Rate</strong>: The rate at which the population of live cells changes over time \( G(t) = \frac{P(t+1) - P(t)}{P(t)} \). Purpose: measures how quickly the population is increasing or decreasing.</p>
                    <p><strong>Stability</strong>: A measure of how quickly a grid reaches equilibrium. One way to compute stability: the number of generations it takes to reach equilibrium.</p>
                    <p><strong>Entropy</strong>: A measure of the disorder or randomness in the grid. One way to compute entropy: \( H(t) = - \sum_{i,j} \left( \frac{\text{grid}[i][j]}{N} \right) \log_2 \left( \frac{\text{grid}[i][j]}{N} \right) \) where \(N\) is the total number of cells.</p>
                </fieldset>
            </div>
            

            <!-- Prism.js JavaScript -->
            <script src="../prism.js"></script> <!-- Adjust the path as needed -->
            <script src="../copycode.js"></script> <!-- Link to your external JavaScript file -->
             
        </div>
        </section>
        
    </div>
</body>
</html>
