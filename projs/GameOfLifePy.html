<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway's Game of Life</title>
    <link rel="stylesheet" href="../prism.css"> <!-- Adjust path as needed -->
    <link rel="stylesheet" href="../style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="../prism.js"></script> <!-- Adjust the path as needed -->
    <script src="../insertCode.js"></script> <!-- Link to your external JavaScript file -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../prism.js"></script>
</head>
<body>
    <a href="https://sarimbaig01.github.io/proghack/" class="back-link top-right">‚Üê Back</a>

    <div class="toc">
        <h2>Contents</h2>
        <a href="#intro">What is the game of life?</a>
        <a href="#terms">Basic terminology</a>
        <a href="#rules">The rules</a>
        <a href="#task1">Task 1: Basic simulation in Python</a>
        <a href="#fterms">Further terminology</a>
        <a href="#task2">Task 2: Make it toroidal</a>
        <a href="#task3">Task 3: Print useful statistics</a>
        <a href="#task4">Task 4: Detect equilibrium</a>
        <a href="#task5">Task 5: Color-code for age</a>
        <a href="#close">Explore more</a>
    </div>

    <div class="statement">
        <h1>Conway's Game of Life</h1>
        <section class="statement">
            <div class="intro" id="intro">
                <h2>What is the game of life?</h2>  
                <p>Conway's Game of Life is a cellular automaton created by mathematician John Conway. t's a zero-player game, meaning its evolution is determined by its initial state without any further input. The game is played on an infinite grid of square cells, each of which can be either <i>alive</i> or <i>dead</i>. The state of the grid evolves in discrete time steps according to a set of simple rules based on the states of neighboring cells. Despite simple rules, the Game of Life can produce incredibly complex and varied patterns, being used in practical applications such as <a href="https://arxiv.org/abs/2009.01398" target="_blank">neural networks research</a> in computer science and <a href="https://pubs.aip.org/aapt/ajp/article/91/7/561/2897367/The-game-of-life-as-a-species-model" target="_blank">simulating population dynamics</a> in theoretical biology</p>
            
            <div class="terms" id="terms">  
            <fieldset>
              <legend>Basic terminology</legend>
              <p><strong>Cell</strong>: The basic unit in the grid, either alive or dead.</p>
              <p><strong>Grid</strong>: The environment where the Game of Life is played, consisting of cells in a two-dimensional array.</p>
              <p><strong>Neighbor</strong>: Any of the eight surrounding cells influencing a cell's future state.</p>
              <p><strong>Alive</strong>: A cell state that is "on" or active, represented by `1`.</p>
              <p><strong>Dead</strong>: A cell state that is "off" or inactive, represented by `0`.</p>
              <p><strong>Initial Configuration</strong>: The starting arrangement of alive and dead cells in the grid.</p>
              <p><strong>Generation</strong>: A time step where the state of each cell is updated based on the game's rules (the initial configuration being generation 0).</p>
              <p><strong>Survival</strong>: A condition where a live cell remains alive in the next generation.</p>
          </fieldset>
          </div>

       
            <div class="rules" id="rules">
              <h2>The rules</h2>
                <p>Conway's Game of Life typically uses the B3/S23 rules, which are the most common despite many possible variations. "B3/S23" means a dead cell with exactly three alive neighbors becomes alive (B3), and a live cell with two or three alive neighbors survives (S23). The rules are:</p>
                <ol>
                  <li>Any live cell with fewer than two alive neighbors dies (the underpopulation rule).</li>
                  <li>A live cell with two or three alive neighbors survives (the survival rule).</li>
                  <li>Any live cell with more than three alive neighbors dies (the overcrowding rule).</li>
                  <li>A dead cell with exactly three alive neighbors becomes alive (the reproduction rule).</li>
                </ol>
            </div>

            <div class="task1" id="task1">
                <h2>Task 1: The basic simulation</h2>
                Consider the following simulation of Conway's Game of Life. This simulation uses a 100x100 grid. This is a good size because it allows intricate patterns to emerge without overwhelming computational resources. In this grid, black cells represent alive states, while white cells represent dead states. The initial configuration of the grid is populated randomly with a mix of alive and dead cells. Our first goal is to write code that can produce such simulations, showing the evolution of this grid over any number of generations, continuing until the window is closed by the user.</p> <div class="video-container">
                    <figure>
                        <video width="320" height="240" autoplay loop muted>
                            <source src="./mov/gol_100_eq.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <figcaption>Figure 1: Python-based simulation using Pygame with a randomly generated initial configuration reaching equilibrium.</figcaption>
                    </figure>
                </div>
                <p>Given below is an incomplete Python code for the basic simulation.</p>
                <p>Copy and run the code. You will see the initial state of the grid but there will be no evolution. <strong> To implement the evolution, complete the following two functions:</strong></p>
                <ul>
                    <li><code><strong>count_alive_neighbors</strong></code> (for <code><strong>update_grid</strong></code>)</li>
                    <li><code><strong>update_grid</strong></code></li>
                </ul>

                <div class="code-container" data-filename="./py/gol1.py">
                    <pre><code class="language-python" id="python-code1">
                        <!-- Code will be loaded dynamically here -->
                    </code></pre>
                </div>
            </div>

            <div class="terms" id="fterms">  
                <fieldset>
                    <legend>Further terminology</legend>
                    <p><strong>Age</strong>: The number of generations a cell has been alive.</p>
                    <p><strong>Pattern</strong>: A specific arrangement of live and dead cells in the grid.</p>
                    <p><strong>Period</strong>: The number of generations it takes for an oscillator to return to its initial state.</p>
                    <p><strong>Spaceship</strong>: A pattern that translates itself across the grid over generations.</p>
                    <p><strong>Glider</strong>: A common type of spaceship that moves diagonally across the grid, consisting of 5 live cells in a specific formation.</p>
                    <p><strong>Oscillator</strong>: A pattern that returns to its initial state after a fixed number of generations, known as its period.</p>
                    <p><strong>Still Lifes</strong>: Stable patterns that do not change from one generation to the next.</p>
                    <p><strong>Equilibrium</strong>: A state where the grid either remains unchanged or cycles through the same sequence of configurations repeatedly.</p>
                    <p><strong>Population</strong>: The total number of live cells in the grid \( P(t) = \sum_{i,j} \text{grid}[i][j] \). Purpose: tracks how the number of live cells changes over generations.</p>
                    <p><strong>Growth Rate</strong>: The rate at which the population of live cells changes over time \( G(t) = \frac{P(t+1) - P(t)}{P(t)} \). Purpose: measures how quickly the population is increasing or decreasing.</p>
                    <p><strong>Stability</strong>: The tendency of a pattern to remain unchanged or return to its original configuration after disturbances. One way to calculate stability is by counting the number of cells that do not change state between generations \( \text{Stability} = \frac{\text{Unchanged Cells}}{\text{Total Cells}} \).</p>
                    <p><strong>Entropy</strong>: A measure of the disorder or randomness in the grid. One way to calculate entropy: \( H(t) = - \sum_{i,j} \left( \frac{\text{grid}[i][j]}{N} \right) \log_2 \left( \frac{\text{grid}[i][j]}{N} \right) \) where \(N\) is the total number of cells.</p>
                </fieldset>
            </div>

            <div class="task2" id="task2">
                <h2>Task 2: Make it toroidal</h2>
                <p>Implement a wrap-around effect by modifying <code><strong>count_alive_neighbors</strong></code> to treat the grid edges as continuous. This creates a toroidal grid, where cells on the edges connect to cells on the opposite side, mimicking an infinite, unbounded environment. This change is beneficial for observing uninterrupted patterns, like oscillators or spaceships moving freely across the grid.</p>
            </div>

            <div class="task3" id="task3">
                <h2>Task 3: Print useful statistics</h2>
                <p>Add code to display statistics for each generation, such as the generation count, live cell population, and growth rate. These statistics provide insight into how the grid evolves and can reveal trends in pattern dynamics. You may print these statistics to the console for easy monitoring as the simulation runs.</p>
                <p>Implement functions to calculate:</p>
                <ul>
                    <li>Generation Number</li>
                    <li>Population (total live cells)</li>
                    <li>Growth Rate</li>
                </ul>
            </div>

            <div class="task4" id="task4">
                <h2>Task 4: Detect equilibrium</h2>
                <p>In this task, you need to detect when the Game of Life grid reaches equilibrium and stop the simulation at that point. This is useful to stop unnecessary computations once the grid no longer changes. Equilibrium is achieved when the grid either becomes static (all cells remain the same) or enters a repeating cycle of configurations (dynamic equilibrium). To detect equilibrium, you need to add the necessary code to identify when the grid reaches one of these states and then stop the simulation, reporting the final statistics. While dynamic equilibrium can theoretically involve long cycles, you only need to cater to cycles of size 10 or less for this task. Make sure to maintain the necessary information and write the required functions to detect equilibrium and manage the simulation accordingly.</p>
           </div>

            <div class="task5" id="task5">
                <h2>Task 5: Color-code for age</h2>
                <p>For this task, you need to maintain the necessary information and write the required code to color-code the simulation based on the age of the cells. In this context, the age of a cell refers to the number of generations it has been alive. Cells that have been alive for longer should appear darker. You can use a gradient where the color darkens progressively with each generation, but for cells that have been alive for 20 generations or more, the color may no longer change. Feel free to experiment with this number to find what works best for your simulation. To achieve this, you will need to modify the code in the draw_grid function. Make sure to update and manage the age of each cell as the simulation progresses. This task will help visualize the longevity and stability of various patterns in the simulation. Ideal visualization depends on several factors, so you are encouraged to experiment with different methods to enhance the quality of your visualization.</p>

                <div class="video-container">
                    <figure style="text-align: center;">
                        <video width="320" height="240" autoplay loop muted>
                            <source src="./mov/gol_col1.mp4" type="video/mp4">
                        </video>
                        <figcaption>Figure 2: Age-based color coding highlights persistent patterns.</figcaption>
                    </figure>
                </div>
                  <p>Some incredibly beautiful things are possible when colorful Game of Life is implemented at high resolutions with interactivity. For example, check out <a href="https://jaxry.github.io/colorful-life/" target="_blank">this beautiful implementation</a> by Lucas Crane.</p>
            </div>
                
            <div class="close" id="close">
            <h1>Explore more</h1>
            <p>Game of Life is a Turing complete system, capable of simulating any computation. By constructing specific patterns, complex circuits and logic gates are possible. Explore the <a href="https://conwaylife.com/wiki/" target="_blank">Conway Life Wiki</a> for tutorials and community insights into this computational marvel.</p>
            </div>
        </section>
    </div>
</body> 
</html>
