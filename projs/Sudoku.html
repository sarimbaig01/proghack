<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku with Exhaustive Search and Heuristics</title>
    <link rel="stylesheet" href="../prism.css"> <!-- Link to your external CSS file -->
    <link rel="stylesheet" href="../style.css"> <!-- Link to your external CSS file -->
     
</head>
<body>
    <a href="https://sarimbaig01.github.io/proghack/" class="back-link top-right">‚Üê Back</a>

    <div class="toc">
        <h2>Contents</h2>
        <a href="#intro">Introduction</a>
        <a href="#terms1">Some terminology</a>
        <a href="#task1">Task 1: Solve a 9x9 Sudoku board</a>
        <a href="#terms2">Further terminology</a>
        <a href="#task2">Task 2: Implement heuristics</a>
        
        <!--<a href="#toroidal" class="sub-item">Make it toriodal</a>
        <a href="#stats" class="sub-item">Print statistics</a>
        <a href="#colors" class="sub-item">Color-code for age</a>
        <a href="#equi" class="sub-item">Detect equilibrium</a>
        <a href="#confs">Simulate different initial configurations</a>-->
    </div>

    <div class="statement">
        <h1>Sudoku with Exhaustive Search and Heuristics</h1>
      <section class="statement">

          <div class="intro" id="intro">
            <h2>Introduction</h2>
            <p>Sudoku is a puzzle game played on a 9x9 board, divided into nine 3x3 subgrids. The goal is to fill the board with digits from 1 to 9 so that each digit appears exactly once in every row, column, and 3x3 subgrid. The puzzle begins with some cells already filled, and the player's task is to fill in the empty cells while following these rules, ensuring no repetition of digits in any row, column, or subgrid.</p>
        
            <p>Figure 1 shows a partially filled input board and a corresponding fully-filled board presenting a valid solution.</p>

              <div class="video-container">
                    <figure style="display: inline-block; margin: 10px; text-align: center;">
                        <!-- Video 1 -->
                        <img  src="./img/Sudoku1a.png">
                        <img  src="./img/Sudoku1b.png">
                        <figcaption>Figure 1: A partially filled Sudoku board representing a typical input and a corresponding solution (a valid output)</figcaption>
                    </figure>
              </div>
    
            <p>For our purposes, each cell on the board will either contain a digit from 1 to 9 or a '.' representing an empty cell. We aim to write a recursive program that receives a partially filled initial state and attempts to reach a fully filled final state that satisfies all the Sudoku rules.</p>
        
          </div>

          <div class="terms1" id="terms1">
            <fieldset>
                <legend>Some terminology</legend>
            
                <p><strong>Solution Search Space:</strong> 
                The solution search space is the set of all possible configurations that could solve a problem. In Sudoku, it includes every potential way to fill the grid with digits 1-9, regardless of whether the configurations follow the Sudoku rules.</p>
            
                <p><strong>Exhaustive Search:</strong> 
                Exhaustive search explores all possible options within the solution search space to find a solution. For Sudoku, this involves trying every combination of numbers until a valid solution is found, but it can be time-consuming due to the large number of possibilities. Typical applications of exhaustive search include solving puzzles like Sudoku, generating permutations and combinations, and finding brute-force solutions to computationally hard problems such as the traveling salesman problem.</p>
            
                <p><strong>Backtracking:</strong> 
                Backtracking is a recursive technique that explores possible solutions by making choices and undoing them if they lead to dead ends. In Sudoku, backtracking places a number in a cell and, if it leads to an invalid configuration, reverses the decision and tries a different number. It is part of the core structure of a recursive algorithm and allows it to navigate through a solution space.</p>
            </fieldset>
          </div>

          <div class="task1" id="task1">
              <h2>Task 1: Solve a 9x9 Sudoku board</h2>
              <p>Our first goal is to write a recursive exhaustive search algorithm to find a solution to a partially filled Sudoku board.</p>
              <h3>Brief explanation of the algorithm:</h3>
              <p>The algorithm works by recursively attempting to place a valid digit in each empty cell. It starts from the first empty cell, tries all possible digits (1-9), and checks if placing a digit violates any Sudoku rules (row, column, or subgrid). If a digit is valid, the algorithm moves to the next empty cell and repeats the process. If a dead end is reached (i.e., no valid digits can be placed in the current cell), the algorithm backtracks to the previous cell and tries the next possible digit. This process continues until the board is completely and correctly filled or all possibilities are exhausted.</p>
              <p>The code below shows various function prototypes need to be implemented. A brief comment against each prototype describes what the function is supposed to do. The main program shows how the function is supposed to be used. You may want to test your program on more inputs.</p>
             
              <div class="code-container" data-filename="./cpp/sudoku1.cpp">
                    <pre>
                         <code class="language-cpp" id="cpp-code1"></code>
                    </pre>
              </div>
              
          </div>
          
          <div class="terms2" id="terms2">
              <fieldset>
                    <legend>Further terminology</legend>
                
                    <p><strong>Goal State:</strong> 
                    The goal state is the desired final configuration or solution in a problem-solving process. In Sudoku, the goal state is the fully completed 9x9 grid where each row, column, and subgrid contains the digits 1-9 without repetition.</p>
                
                    <p><strong>Heuristic Function (h(n)):</strong> 
                    A heuristic function, denoted as <code>h(n)</code>, is an estimate used to guide search algorithms toward the goal state more efficiently. It predicts the cost or distance from the current state to the goal state, helping to prioritize paths that are more likely to lead to a solution.</p>
              </fieldset>
          </div>

           <div class="task2" id="task2">
              <h2>Task 2: Implement heuristics</h2>
                <p>In exhaustive search, we could be searching in subtrees that will not ultimately lead to a solution (goal state). This can be highly inefficient as it wastes time exploring paths that don't contribute to finding the correct answer.</p>

                <p>Heuristics can be used to prioritize subtrees (or paths) that are more likely to lead to a solution based on common-sense rules or educated guesses. By applying these heuristics, the search process is likely to become less wasteful by focusing on more promising paths, even though wasteful execution, and in particular the worst-case scenario, are still possible.</p>
                
                <p>The input of a function like h(n) is the current state n, and its output is an estimate of the cost or distance from this state to the goal state. This estimate helps guide the search algorithm toward more promising paths, improving efficiency.</p>
                
                <p>Now, we will introduce two heuristics for Sudoku that can be implemented to enhance the solving process.</p>

                <p>continued...</p>
              
          </div>

        <!-- Prism.js JavaScript -->
        <script src="../prism.js"></script> <!-- Adjust the path as needed -->
        <script src="../insertCode.js"></script> <!-- Link to your external JavaScript file -->
      </section>
    </div>
</body>
</html>



