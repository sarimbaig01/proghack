<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problem 2.2 Large Spiked Rectangles</title>
    <link rel="stylesheet" href="../prism.css"> <!-- Link to your external CSS file -->
    <script src="../prism.js"></script> <!-- Adjust the path as needed -->
    <script src="../insertCode.js"></script> <!-- Link to your external JavaScript file -->
    <link rel="stylesheet" href="../style.css"> <!-- Link to your external CSS file -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <a href="https://sarimbaig01.github.io/proghack/" class="back-link top-right">‚Üê Back</a>

    <div class="statement">
    <h1> Problem 2.2 Large Spiked Rectangles </h1>
        <section class="statement">
          <p>Spikeless rectangles provide a reasonable approximation for high black intensity regions, but they have some limitations. For example, since the area of the rectangle is computed using its sides, rectangles with small internal bars may be selected, resulting in regions of the image that have low black intensity in the interior.</p>

          <p>A better approach is to consider all rectangles, including those that may (or may not) contain spikes. Moreover, we modify the definition of the height of a rectangle as below.</p>

           <fieldset>
              <legend>Height of a rectangle</legend>
                The height of a rectangle is the height of its shortest bar, which may be an internal or side bar.
            </fieldset>

            <p>Figure 1 below shows two examples of largest rectangles with spikes and their corresponding areas. Please note that although these examples show rectangles that do contain spikes, if a spikeless rectangle with larger area exists, it will be chosen as the largest rectangle. We simply do not need to check for spikelessness in this problem.</p>
          
            <div class="single-image-container">
                    <figure style="display: inline-block; margin: 10px; text-align: center;">
                        <img src="./img/LargeRectangles3a.png" width="500" height="500"/>
                        <img src="./img/LargeRectangles3b.png" width="500" height="500"/>
                        <figcaption>Figure 1: Two different examples of largest rectangles with spikes and their corresponding areas.</figcaption>
                    </figure>
            </div> 

            <h3>Python code</h3>
            <p>Once again, our first task is to write a quadratic time algorithm to compute the largest rectangle (which may or may not contain spikes). We will inspect all possible rectangles and do not need to check for spikelessness. Simply be careful to use the height of the shortest bar as the height of the rectangle.</p>

            <p>Implement the following Python function for this purpose:</p>

            <div class="code-container" data-filename="./py/lr5.py">
                <pre><code class="language-python" id="py-code">
                </code></pre>
            </div>

            <p>Use the following main to test your function:</p>
  
            <div class="code-container" data-filename="./py/lr7.py">
                <pre><code class="language-python" id="py-code">
                </code></pre>
            </div>

            <h3>The linear time method</h3>

            <p>It is possible to compute the largest rectangle in linear time by making only two scans of the input list.</p>

            <p>To understand the main insights used in this method, consider the following:</p>
            <ul>
              <li>Every rectangle (including the largest one) has its right boundary at one of the bars in the input. We can therefore think of rectangles in terms of their right sides.</li>
              <li>Specifically, we can compute the largest rectangle ending at each bar \(i\). Additionally, we will store the height of each of these largest rectangles ending at specific bars.</li>
              <li>The main insight is this: if we know the best rectangle ending at bar \(i - 1\) and the height of this rectangle, we can easily compute the largest rectangle ending at bar \(i\) and its height.</li>
              <li>Once we have computed the largest rectangles ending at all bars \(i\) and their corresponding heights, we can scan through them once and find the largest rectangle overall.</li>
            </ul>
            
            <p>We will use two auxiliary lists to store rectangles and their heights.</p>
            
            <p> We define:
            <ul>
              <li><strong>left_boundaries[i]</strong>: the index of the left boundary of the largest rectangle ending at bar \(i\)</li>
              <li><strong>rect_height[i]</strong>: the height of the largest rectangle ending at bar \(i\)</li>
            </ul>
            </p>
            
            <p>Initially:</p>
            <ul>
              <li><strong>left_boundaries[0] = 0</strong></li>
              <li><strong>rect_height[0] = count[0]</strong></li>
            </ul>
            </p>
            
            <p>The specific problem for you to solve is the following:</p>
            
            <p>Given the values of <strong>left_boundaries[i-1]</strong> and <strong>rect_height[i-1]</strong>, how does one compute <strong>left_boundaries[i]</strong> and <strong>rect_height[i]</strong>? This will not require looping through the lists if done carefully.</p>
            
            <p>Once the lists <strong>left_boundaries</strong> and <strong>rect_height</strong> have been fully populated, we can scan them once, compute areas of corresponding rectangles, and report the overall largest rectangle.</p>
            
            <p>Following is a Python function stub containing some part of the code. Complete this implementation and use the same main as above to test your code. Please be careful to ensure linear running time.</p>


            <div class="code-container" data-filename="./py/lr6.py">
                <pre><code class="language-python" id="py-code">
                </code></pre>
            </div>

            <h3>Further improvement</h3>

            <p>Since we only need <strong>left_boundaries[i-1]</strong> and <strong>rect_height[i-1]</strong> for the computation of these values at \(i\), we do not need to store the lists but only two variables corresponding to the values of <strong>left_boundaries[i-1]</strong> and <strong>rect_height[i-1]</strong>. In this case, we will need to maintain <strong>max_left</strong>, <strong>max_right</strong>, and <strong>max_area</strong> as we compute the rectangles. This way, we will no longer require the extra scan through the lists at the end to find the largest rectangle.</p>

          
        </section>
      </div>
</body>
</html>
